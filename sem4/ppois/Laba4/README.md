# **Документация веб-приложения системы столовой**

  

#### Версия: 1.0

  

#### Автор: [RivaKing]

  

---

## **Оглавление**

  

1. [Описание проекта](#)
2. [Структура проекта](#)
3. [Описание функций](#)
  
  

---

## **Описание проекта**

  

Эта система предназначена для управления столовой в веб-интерфейсе.

Она позволяет:



- Добавлять и удалять новые блюда в/из меню.
  
- Нанимать новых сотрудников.
  
- Запустить симуляцию работы системы столовой.
  
- Отслеживать сосотяние зала и таблицы заказов.
  
- Готовить и отдавать новые заказы.
  

Приложение написано на **Python** с использованием фреймворка **FastAPI** для создания бекэнда и маршрутов апи. **JavaScript** для управления веб-страницей и взаимодейсвтия пользователя с данными. **HTML** для структуры страницы. **CSS** Для стилизации страницы

  

---

## **Структура проекта**

```

/Laba4 
   | backend # Папка с бекэндом  
        | routes # Папка с маршрутами
            | customers.py # Управление посетителями
            | employee.py # Маршруты управления сотрудниками
            | game.py # Управление состоянием игры
            | hall.py # Эндпоинты зала с посетителями
            | menu.py # Апи для меню
            | orders.py # Заказы
            | timer.py # Таймер для обновления данных
        | app.py # Запуск сервера и получение страницы
        | models.py # Хранения данных системы
    | frontend # Файл фронтенда
        | static # Статичные файлы
            | dishes.js # Отображение и добавление блюд
            | employees.js # Меню сотрудников
            | eventHandler # Задание свойств кнопкам
            | game.js # Старт игры
            | hall.js # Отображение зала и выдача заказов
            | order.js # Таблица заказов
            | ui.js # Обновление состояния игры
            | variables.js # Подключение кнопок и других элементов html
        | templates # Динамичные файлы
            | index.html # Структура страницы
    | requirements.txt # Зависимости
```
  

---

## **Описание функций**

## **Backend**

### **1. spawn_customers()**

**Описание:**

Функция `spawn_customers()` отвечает за случайное появление новых клиентов в игре, пока игра активна, есть время и доступные блюда в меню. Она работает асинхронно в фоновом режиме.

- Проверяет условия: игра активна (`models.game_active`), осталось время (`time_left > 0`), есть блюда в меню (`len(routes.menu.dishes) > 0`), и текущее количество клиентов меньше максимального (`max_customers = 5`).
- С вероятностью `1 - customers_range` (где `customers_range = 0.1`, то есть 90% шанс) создаёт нового клиента, если есть свободные столы.
- Выбирает случайный свободный стол из списка `routes.hall.tables`, занимает его (`occupied = True`), увеличивает счётчик клиентов и заказов в `models.game_state`, и добавляет новый заказ через `routes.orders.add_order()` с случайным блюдом из меню.
- После каждой итерации ждёт 3 секунды (`await asyncio.sleep(3)`), чтобы клиенты появлялись не слишком часто.

---

### **2. hire_employee()**

**Описание:**

Функция `hire_employee()` позволяет нанимать нового сотрудника для игры.

- Принимает словарь `employee` с полями `name` (имя сотрудника) и `cost` (стоимость найма).
- Проверяет, не нанят ли сотрудник уже (проверка наличия `name` в списке `employees`) и достаточно ли денег в `models.game_state["money"]` для оплаты найма.
- Если условия выполнены, добавляет сотрудника в список `employees`, вычитает стоимость найма из денег игрока и возвращает успешный результат (`{"success": True}`).
- В противном случае возвращает сообщение об ошибке: либо сотрудник уже нанят, либо недостаточно денег.

---

### **3. start_game()**

**Описание:**

Функция `start_game()` инициализирует новую игровую сессию.

- Сбрасывает состояние игры в `models.game_state`, устанавливая начальные значения: `money = 0` (деньги), `customers = 0` (клиенты), `orders = 0` (заказы), `time_left = 60` (время в секундах).
- Устанавливает флаг активности игры (`models.game_active = True`).
- Запускает две асинхронные задачи: `spawn_customers()` для появления клиентов и `run_timer()` для отсчёта времени.
- Возвращает успешный результат (`{"success": True}`), сигнализируя о старте игры.

---

### **4. take_order()**

**Описание:**

Функция `take_order()` позволяет принять заказ от клиента.

- Проверяет, есть ли активные клиенты (`customers > 0`) и заказы (`orders > 0`) в `models.game_state`.
- Если условия выполнены, уменьшает количество заказов на 1 (`orders -= 1`) и возвращает успешный результат с сообщением (`"Заказ принят"`).
- Если заказов или клиентов нет, возвращает ошибку (`"Нет заказов для принятия"`).
- Эта функция, вероятно, используется как промежуточный шаг перед приготовлением еды.

---

### **5. serve()**

**Описание:**

Функция `serve()` обслуживает клиента после выполнения заказа.

- Проверяет, есть ли клиенты для обслуживания (`customers > 0`) в `models.game_state`.
- Если клиенты есть, уменьшает их количество на 1 (`customers -= 1`), добавляет 50 рублей к деньгам игрока (`money += 50`) и возвращает успешный результат с сообщением (`"Клиент обслужен"`).
- Если клиентов нет, возвращает ошибку (`"Нет клиентов для обслуживания"`).
- Эта функция завершает цикл обслуживания клиента после приготовления и выдачи заказа.

---

### **6. issue_order(order: dict)**

**Описание:**

Функция `issue_order()` обрабатывает завершение заказа для определённого стола.

- Принимает словарь `order` с номером стола (`table`), который уменьшается на 1 для соответствия индексу в списке `tables`.
- Проверяет, есть ли активные заказы в `routes.orders.orders` и существует ли заказ для указанного стола.
- Если заказ найден и стол занят (`occupied = True`), проверяет, завершён ли заказ (`completed = True`).
- Если завершён: уменьшает счётчики `orders` и `customers` в `models.game_state`, добавляет 50 рублей к `money`, освобождает стол (`occupied = False`), удаляет заказ из списка и возвращает сообщение об успешном обслуживании.
- Если не завершён: возвращает ошибку (`"Заказ для стола еще не выполнен"`).
- Если стол не занят или заказов нет, возвращает соответствующую ошибку.

---

### **7. add_dish(dish: dict)**

**Описание:**

Функция `add_dish()` добавляет новое блюдо в меню игры.

- Принимает словарь `dish` с полем `name` (название блюда).
- Проверяет, указано ли название и отсутствует ли оно в списке `dishes`.
- Если условия выполнены, добавляет блюдо в `dishes` и возвращает успешный результат (`{"success": True}`).
- Если блюдо уже существует или название пустое, возвращает ошибку с соответствующим сообщением.

---

### **8. remove_dish(dish: dict)**

**Описание:**

Функция `remove_dish()` удаляет блюдо из меню игры.

- Принимает словарь `dish` с полем `name` (название блюда).
- Проверяет, есть ли блюдо в списке `dishes`.
- Если блюдо найдено, удаляет его и возвращает успешный результат (`{"success": True}`).
- Если блюда нет в списке, возвращает ошибку (`"Блюдо не найдено"`).

---

### **9. cook_order()**

**Описание:**

Функция `cook_order()` отмечает заказ как приготовленный.

- Принимает словарь `order` с полями `table` (номер стола) и `dish` (название блюда).
- Ищет в списке `orders` заказ с указанным столом и блюдом, который ещё не приготовлен (`completed = False`).
- Если заказ найден, устанавливает `completed = True` и возвращает успешный результат с сообщением о приготовлении.
- Если заказ не найден или уже приготовлен, возвращает ошибку (`"Заказ не найден или уже приготовлен"`).

---

### **10. run_timer()**

**Описание:**

Функция `run_timer()` отсчитывает оставшееся время игры.

- Работает асинхронно, пока `time_left > 0` и `game_state` существует.
- Каждую секунду уменьшает `time_left` в `models.game_state` на 1 (`time_left -= 1`) и выводит текущее значение в консоль для отладки.
- После достижения нуля устанавливает `models.game_active = False`, завершая игру, и выводит сообщение об остановке таймера.

## **Frontend**

### **1. fetchOrders()**

**Описание:**

Асинхронная функция `fetchOrders()` отвечает за получение и отображение списка заказов из API.

- Получает элемент списка заказов через `document.getElementById("orderList")`.
- Запрашивает данные о заказах через `fetch('/api/orders')` и преобразует ответ в JSON.
- Очищает содержимое `orderListElement` перед обновлением.
- Если список заказов пуст (`orders.length === 0`), отображает сообщение `"Список заказов пуст"` и добавляет класс `"empty"` для стилизации.
- Если заказы есть:
  - Удаляет класс `"empty"`.
  - Для каждого заказа создаёт элемент `<div>` с классом `"order-item"`.
  - Отображает информацию о заказе (`"Столик ${order.table}: ${order.dish}"`).
  - Для выполненных заказов (`order.completed`):
    - Зачёркивает текст (`textDecoration: "line-through"`).
    - Меняет цвет текста на серый (`color: "#888"`).
  - Создаёт кнопку `"Приготовить"`, отключает её для выполненных заказов и добавляет обработчик `click`:
    - Отправляет POST-запрос на `/api/cook_order` с данными `{ table, dish }`.
    - При успешном ответе обновляет список заказов через `fetchOrders()`.
    - При ошибке выводит сообщение через `alert`.
- Обрабатывает ошибки через `try/catch`, логируя их в консоль.

---

### **2. disableButtons()**

**Описание:**

Функция `disableButtons()` отключает кнопки взаимодействия с залом и заказами после завершения игры.

- Отключает кнопку зала (`document.getElementById("hall").disabled = true`).
- Отключает кнопку заказов (`document.getElementById("orders").disabled = true`).

---

### **3. startPolling()**

**Описание:**

Функция `startPolling()` запускает периодическое обновление состояния игры, заказов и столов.

- Использует `setInterval` для выполнения каждые 500 мс.
- Проверяет, активна ли игра (`gameActive`).
- Если игра активна, вызывает:
  - `fetchGameState()` для обновления состояния игры.
  - `fetchOrders()` для обновления списка заказов.
  - `fetchTables()` для обновления списка столов.

---

### **4. startGame()**

**Описание:**

Асинхронная функция `startGame()` инициализирует новую игровую сессию.

- Запрашивает список блюд через `fetch('/api/dishes')`.
- Если блюд нет (`dishesData.length === 0`), выводит `alert("Нет блюд в меню")` и прерывает выполнение.
- Скрывает стартовую панель (`startPanel.classList.add("hidden")`).
- Отправляет POST-запрос на `/api/start_game`.
- При успешном ответе (`gameData.success`):
  - Устанавливает `gameActive = true`.
  - Активирует кнопки `"orders"` и `"hall"`.
  - Отключает кнопки `"employee"` и `"menu"`.
  - Отключает кнопку старта (`startGameBtn.disabled = true`).
  - Запускает `startPolling()`.
- При ошибке логирует её в консоль и выводит `alert`.

---

### **5. updateUI(data)**

**Описание:**

Функция `updateUI()` обновляет пользовательский интерфейс на основе данных состояния игры.

- Обновляет:
  - Деньги: `cashElement.textContent = data.money`.
  - Время: `timeElement.textContent = data.time_left`.
  - Клиентов: `customersElement.textContent` — отображает `"Клиентов: ${data.customers}, заказов: ${data.orders}"`, если клиенты есть, или `"Клиентов нет"`.

---

### **6. fetchGameState()**

**Описание:**

Асинхронная функция `fetchGameState()` получает текущее состояние игры из API.

- Запрашивает данные через `fetch('/api/game_state')` и преобразует в JSON.
- Вызывает `updateUI(data)` для обновления интерфейса.
- Если время истекло (`data.time_left <= 0`) и игра активна:
  - Устанавливает `gameActive = false`.
  - Выводит `alert` с результатом игры.
  - Вызывает `disableButtons()`.
  - Активирует кнопки `"employee"` и `"menu"`.
  - Включает кнопку старта (`startGameBtn.disabled = false`).
- Обрабатывает ошибки через `try/catch`, логируя их в консоль.

---

### **7. checkGameStateOnLoad()**

**Описание:**

Асинхронная функция `checkGameStateOnLoad()` проверяет состояние игры при загрузке страницы.

- Запрашивает данные через `fetch('/api/game_state')`.
- Если `data.time_left > 0`, устанавливает `gameActive = true` и запускает `startPolling()`.
- Обрабатывает ошибки через `try/catch`, логируя их в консоль.

---

### **8. fetchTables()**

**Описание:**

Асинхронная функция `fetchTables()` получает и отображает список столов из API.

- Получает элемент `tableListElement` через `document.getElementById("tableList")`.
- Запрашивает данные через `fetch('/api/tables')`.
- Очищает содержимое `tableListElement`.
- Для каждого стола:
  - Создаёт `<div>` с классом `"table-item"`.
  - Отображает имя стола (`table.name`) с цветом: красный для занятых (`occupied: true`), зелёный для свободных.
  - Создаёт кнопку `"Обслужить"`, активную только для занятых столов.
  - Добавляет обработчик `click`:
    - Отправляет POST-запрос на `/api/issue_order` с номером стола.
    - При успехе обновляет список столов и состояние игры, выводит `alert`.
    - При ошибке выводит сообщение.
- Обрабатывает ошибки через `try/catch`, логируя их в консоль.

---

### **9. fetchEmployees()**

**Описание:**

Асинхронная функция `fetchEmployees()` отображает список доступных сотрудников и их статус.

- Запрашивает список нанятых сотрудников через `fetch('/api/employees')`.
- Очищает `employeeListElement`.
- Для каждого сотрудника из `availableEmployees`:
  - Создаёт `<div>` с классом `"employee-item"`.
  - Отображает имя и стоимость (если не нанят) или только имя (если нанят).
  - Если сотрудник нанят (`hiredEmployees.includes(employee.name) || employee.hired`):
    - Добавляет галочку (`✓`) с классом `"hired-check"`.
  - Если не нанят:
    - Создаёт кнопку `"Нанять"` с обработчиком `click`:
      - Отправляет POST-запрос на `/api/hire_employee` с данными `{ name, cost }`.
      - При успехе обновляет список сотрудников и состояние игры.
      - При ошибке выводит сообщение.
- Обрабатывает ошибки через `try/catch`, логируя их в консоль.

---

### **10. fetchDishes()**

**Описание:**

Асинхронная функция `fetchDishes()` получает и отображает список блюд из API.

- Запрашивает данные через `fetch('/api/dishes')`.
- Очищает `dishListElement`.
- Если блюд нет (`dishes.length === 0`):
  - Отображает `"Список блюд пуст"` с центрированием текста.
- Если блюда есть:
  - Для каждого блюда создаёт `<div>` с классом `"dish-item"`.
  - Отображает название блюда.
  - Создаёт кнопку `"Удалить"` с обработчиком `click`:
    - Отправляет POST-запрос на `/api/remove_dish` с названием блюда.
    - При успехе обновляет список блюд.
    - При ошибке выводит сообщение.
- Обрабатывает ошибки через `try/catch`, логируя их в консоль.

---

### **11. addDishHandler()**

**Описание:**

Функция `addDishHandler()` добавляет новое блюдо в меню.

- Получает название блюда из `dishInput.value.trim()`.
- Если название указано:
  - Отправляет POST-запрос на `/api/add_dish` с данными `{ name }`.
  - При успехе очищает поле ввода, скрывает панель добавления и обновляет список блюд.
  - При ошибке выводит сообщение.
- Если название пустое, выводит `alert("Введите название блюда")`.
- Обрабатывает ошибки через `.catch`, логируя их в консоль.
